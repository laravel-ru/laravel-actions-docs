# Как это работает?

## Украшение ваших действий

Всякий раз, когда Вы используете или регистрируете свое действие как шаблон фреймворка, например контроллер, слушатель и т. д. - Ваше действие никогда не используется напрямую в качестве этих шаблонов. Вместо этого **создается новый декоратор, который обертывает и делегирует Ваше действие**.

![Схема декораторов](/how-decorators.png)

Основная причина этого - обеспечение полного контроля над своим PHP-классом. Нет необходимости расширять класс `Command`; нет необходимости реализовывать свое действие вокруг запроса API или события; нет необходимости превращать Ваше действие в очередь `Queueable`, которое должно быть сериализуемым; и т.п.

Вместо этого Вы просто сосредотачиваетесь на написании своего класса так, как Вы хотите, без каких-либо принудительных зависимостей.

Еще одна важная причина декорирования действий - избежать конфликта между узорами. Если Ваше действие напрямую использовалось в качестве контроллера, задания, слушателя и команды, то эти шаблоны неизбежно вступили бы в конфликт друг с другом. Например, у Вас есть мидлвар как для контроллеров, так и для заданий, но это разные типы мидлваров.

Другой пример - как выполняется само действие. Контроллеры создаются один раз и повторно используются для каждого запроса, тогда как слушатели создаются по запросу. С декораторами Вам не о чем беспокоиться. Вы просто пишете свое действие и уверены, что оно будет разрешаться и выполняться каждый раз, независимо от того, в качестве контроллера или как слушателя.

## Определение того, как выполняется действие

Теперь Вы знаете, что если действие выполняется как контроллер, оно будет заключено в `ControllerDecorator`, но как Laravel Actions знает, что оно выполняется как контроллер в первую очередь?

Действия Laravel не расширяют и не переопределяют какие-либо основные компоненты Laravel для идентификации шаблонов. Вместо этого он добавляет перехватчик внутри контейнера IoC, который анализирует `debug_backtrace`, чтобы определить, как было отправлено действие.

Чтобы убедиться, что перехватчик только перехватывает действия, Laravel Actions использует комбинацию **перед разрешением обратных вызовов** и **расширителей**.

**До разрешения обратные вызовы** были введены в Laravel 8.15 и позволяют добавлять обратные вызовы прямо перед тем, как `abstract` будет разрешен из контейнера. Если `abstract` использует трейт из Laravel Actions, например, `AsController`, то мы добавляем один расширитель для этого действия. Этот расширитель добавляется не более одного раза за действие.

**Расширители** - это функции обратного вызова, которые позволяют Вам преобразовывать то, что разрешается из контейнера. Расширитель, добавленный Laravel Actions, использует `debug_backtrace` для определения того, как было отправлено действие. Если шаблон не был идентифицирован, он просто возвращает само действие, то есть мы используем его как объект. Laravel Actions также использует этот расширитель, чтобы определить, является ли действие имитируемым, и возвращает поддельный экземпляр, если это так.

Обратите внимание, что он определяет шаблоны на основе характеристик, используемых в действии. Например. если в действии не используется трейт `AsController`, включенный по умолчанию в `AsAction`, то расширитель не будет пытаться идентифицировать его как контроллер.

На изображении ниже представлена упрощенная диаграмма того, как расширитель влияет на разрешение контейнера.

![Диаграмма разрешения контейнера](/how-resolution.png)
