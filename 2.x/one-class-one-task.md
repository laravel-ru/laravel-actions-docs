# Один класс, одна задача

Действия Laravel предоставляют новую «единицу жизни» в Вашем приложении: **Действие**.

Это побуждает Вас сосредоточиться на том, что на самом деле делает Ваше приложение, а не на шаблонах фреймворка, на которые оно опирается.

## Конкретно, что такое действие?

Действие может быть любым PHP-классом с методом `handle`. Просто добавьте к этому классу трейт `AsAction` - и вуаля, у Вас есть действие.

У него есть только одно ограничение: **он должен иметь возможность разрешать из контейнера** - это означает, что приложение `app(MyAction::class)` не должно завершаться ошибкой.

Это означает, что Вы можете использовать конструктор для внедрения зависимостей в свои действия.

```php
use Lorisleiva\Actions\Concerns\AsAction;

class MyFirstAction
{
    use AsAction;

    protected MyInjectedService $service;

    public function __construct(MyInjectedService $service)
    {
        $this->service = $service;
    }

    public function handle(...$someArguments)
    {
        // Ваша логика действий здесь...
    }
}
```

<small>Обратите внимание, что в Laravel Actions используется трейт вместо наследования, чтобы быть максимально ненавязчивым. Если Вы предпочитаете наследование, Вы можете использовать эквивалент `extends \Lorisleiva\Actions\Action`. Если Вы не предпочитаете наследование, Вас может заинтересовать "[Более детально о трейтах](./granular-traits)".</small>

## Запуск как объект

Поскольку у Вас есть полный контроль над своими классами действий, Вам действительно не нужны Laravel Actions, чтобы запускать их как объект.

Однако Laravel Actions предоставляет Вам два вспомогательных статических метода: `make` и `run`. Это облегчает Вам **создание экземпляра** и **выполнение** Вашего действия соответственно.

```php
// Эквивалентно "app(MyFirstAction::class)".
MyFirstAction::make();

// Эквивалентно "MyFirstAction::make()->handle($myArguments)".
MyFirstAction::run($myArguments);
```

Рекомендуется использовать эти методы для создания экземпляра действия, чтобы оно всегда разрешалось из контейнера. Таким образом:
- Всегда можно использовать инъекцию зависимостей в конструкторе.
- Можно заменить действие макетом в тестах (смотрите раздел "[Макет и проверка действий](./mock-and-test)").

## Рекомендуемые условные обозначения

Несмотря на то, что у Вас есть полный контроль над тем, как реализовать свои действия, несколько незначительных соглашений могут помочь Вам оставаться последовательными при организации Вашего приложения. Вот два рекомендуемых.

### Начни с глагола

Назовите свои классы действий **маленькими явными предложениями, начинающимися с глагола**. Например, действие, которое «отправляет электронное письмо пользователю для сброса пароля», может называться `SendResetPasswordEmail`.

Таким образом, Ваша структура папок становится почти исчерпывающим словарем всего, что предоставляет Ваше приложение. Это подводит нас ко второму рекомендуемому соглашению.

### Используйте папку `Actions`

Создайте папку `app/Actions` и сгруппируйте свои действия внутри этой папки по темам. Вот простой пример.

```
app/
├── Actions/
│   ├── Authentication/
│   │   ├── LoginUser.php
│   │   ├── RegisterUser.php
│   │   ├── ResetUserPassword.php
│   │   └── SendResetPasswordEmail.php
│   ├── Leads/
│   │   ├── BulkRemoveLead.php
│   │   ├── CreateNewLead.php
│   │   ├── GetLeadDetails.php
│   │   ├── MarkLeadAsCustomer.php
│   │   ├── MarkLeadAsLost.php
│   │   ├── RemoveLead.php
│   │   ├── SearchLeadsForUser.php
│   │   └── UpdateLeadDetails.php
│   └── Settings/
│       ├── GetUserSettings.php
│       ├── UpdateUserAvatar.php
│       ├── UpdateUserDetails.php
│       ├── UpdateUserPassword.php
│       └── DeleteUserAccount.php
├── Models/
└── ...
```

В качестве альтернативы, если Ваше приложение уже разделено на темы или модули, Вы можете создать папку `Actions` под каждым из этих модулей. Например:

```
app/
├── Authentication/
│   ├── Actions/
│   ├── Models/
│   └── ...
├── Leads/
│   ├── Actions/
│   ├── Models/
│   └── ...
└── Settings/
    ├── Actions/
    └── ...
```

## Как это работает?

До сих пор мы видели только, как запускать действия как объекты, но Вам может быть интересно, как Ваши классы будут выполняться как контроллеры, задания и т. д.

Laravel Actions делает это, добавляя в контейнер специальный перехватчик, который распознает, как выполняется класс. Когда это происходит - и это важная часть - **он оборачивает Ваш PHP-класс в декоратор, который будет делегировать Ваше действие, когда это необходимо**. У каждого шаблона проектирования есть собственный декоратор - например, `ControllerDecorator`, `JobDecorator` и так далее. Это означает, что Вы по-прежнему полностью контролируете свой PHP-класс и Вам не нужно беспокоиться о конфликте между различными шаблонами проектирования.

Посетите страницу "[Как это работает?](./how-does-it-work)" если Вы хотите узнать об этом больше.

Теперь перейдем к [контроллерам](./register-as-controller).
