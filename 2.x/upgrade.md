# Обновление с 1.x

Laravel Actions v2 был переписан с нуля и предлагает несколько иную парадигму, чем v1. Поэтому, честно говоря, обновление до версии 2 не будет тривиальным.

## Другая парадигма

Основное отличие состоит в том, что v1 использует массив атрибутов - аналогично тому, как работают модели Eloquent - для унификации данных между шаблонами (то есть контроллерами, заданиями, слушателями и т. д.).

Кроме того, само действие становится шаблоном. Итак, если Вы выполняете действие как контроллер и задание, действие должно действовать как контроллер и как задание.

Это требует, чтобы действие расширяло класс `Action`, который действует как гибрид всех поддерживаемых шаблонов и переопределяет некоторые основные компоненты Laravel, чтобы это работало.

```php
// v1
class UpdateUserPassword extends Action
{
    public function handle(): void
    {
        $this->user()->update([
            'password' => Hash::make($this->password),
        ]);
    }
}
```

С другой стороны, v2 больше не заставляет Ваши действия что-либо расширять и дает Вам свободу писать классы действий именно такими, какими Вы хотите их видеть. Вместо этого он использует трейты для предоставления вспомогательных методов и распознавания того, что Ваше действие должно выполняться определенным образом.

Каждый шаблон имеет свой собственный трейт — `AsController`, `AsJob` и т. д. - и объединяется в трейт `AsAction` (Смотрите "[Более детализированные трейты](./granular-traits)").

Кроме того, Ваше действие больше не используется напрямую в качестве шаблона. Вместо этого он заключен в декоратор, который будет делегировать Ваши действия, когда это необходимо (Смотрите "[Как это работает?](./how-does-it-work)").


```php
// v2
class UpdateUserPassword
{
    use AsAction;

    public function handle(User $user, string $newPassword): void
    {
        $user->update([
            'password' => $newPassword,
        ]);
    }
}
```

Суть в том, что рефакторинг с v1 на v2 может быть хорошей возможностью переосмыслить некоторые из Ваших действий теперь, когда Вы можете реализовать их без каких-либо ограничений.

Хотя невозможно предоставить пошаговое руководство по обновлению до версии 2, следующие разделы посвящены предоставлению фрагмента кода до/после, чтобы помочь Вам увидеть, что изменилось.

## Больше никаких атрибутов

В Ваших действиях больше нет набора атрибутов.

```php
// v1
class CreateNewArticle extends Action
{
    public function handle(): Article
    {
        return $this->user()->articles()->create([
            'title' => $this->title,
            'body' => $this->body,
        ]);
    }
}

// v2
class CreateNewArticle
{
    use AsAction;

    public function handle(User $author, string $title, string $body): Article
    {
        return $author->articles()->create([
            'title' => $title,
            'body' => $body,
        ]);
    }
}
```

## Авторизация и проверка только для контроллеров

Поскольку у нас больше нет атрибутов для унификации данных между шаблонами, авторизация и проверка будут влиять на действие только тогда, когда оно выполняется как контроллер - и, следовательно, когда запрос доступен.

## Внедрение зависимостей в конструкторе

Поскольку Ваши действия всегда будут разрешаться из контейнера, теперь Вы можете использовать метод `__construct`, чтобы добавить некоторые зависимости в Ваше действие.

```php
// v2
class GetDirectionsToRestaurant
{
    use AsAction;

    protected GoogleMapsService $googleMaps;

    public function __construct(GoogleMapsService $googleMaps)
    {
        $this->googleMaps = $googleMaps;
    }
}
```

## Один метод для ввода и вывода

В версии 1 Вы можете использовать методы `asX` для вставки логики *перед* выполнением метода `handle` и/или методы `getAttributesFromX` для обеспечения пользовательского синтаксического анализа между шаблоном и атрибутами. Затем Вам нужно будет реализовать другой метод, такой как `response` или `consoleOutput`, чтобы вставить логику *после* метода `handle`.

В версии 2 Вам больше не нужно помнить, какой метод вызывать для привязки данных до и/или после каждого шаблона. Вместо этого у Вас есть ровно одна точка входа для каждого шаблона: `asController`, `asCommand`.

Эти методы теперь отвечают как за ввод, так и за вывод этого шаблона, поскольку Вы будете вызывать метод `handle` прямо там.

```php
// v1
class CreateNewArticle extends Action
{
    public function getAttributesFromCommand(Command $command): array
    {
        $this->actingAs(User::findOrFail($command->argument('user_id')));

        return [
            'title' => $command->argument('title'),
            'body' => $command->argument('body'),
        ];
    }

    public function handle(): Article
    {
        return $this->user()->articles()->create([
            'title' => $this->title,
            'body' => $this->body,
        ]);
    }

    public function consoleOutput($article, Command $command): void
    {
        $command->info("Article \"{$article->title}\" created.");
    }
}

// v2
class CreateNewArticle
{
    use AsAction;

    public function handle(User $author, string $title, string $body): Article
    {
        return $author->articles()->create([
            'title' => $title,
            'body' => $body,
        ]);
    }

    public function asCommand(Command $command): Article
    {
        $article = $this->handle(
            User::findOrFail($command->argument('user_id')),
            $command->argument('title')),
            $command->argument('body')),
        );

        $command->info("Article \"{$article->title}\" created.");
    }
}
```

## Очередь фейков и декораторов джоба

Если Вы используете `Queue::fake()` в своих тестах, чтобы убедиться, что действие было отправлено как задание, эти тесты теперь не пройдут из-за того, что задание теперь является `JobDecorator`, обертывающим Ваше действие, а не само действие.

Чтобы исправить это, Вам просто нужно заменить `Queue::assertPushed(MyAction::class)` на `MyAction::assertPushed()`.

Смотрите ["Подтверждение заданий, которые были отправлены"](./dispatch-jobs.html#asserting-jobs-were-pushed) для получения дополнительной информации.

## Карта методов и свойств

В таблице ниже показано соответствие между методами и свойствами, доступными в v1, и доступными в v2, упорядоченными в алфавитном порядке.

| v1 | v2 | Комментарии |
| - | - | - |
| `actingAs` | *Удалено* | Больше никаких помощников пользователей. Если действие требует, чтобы пользователь работал, просто передайте этого пользователя в качестве аргумента. |
| `afterValidator` | `afterValidator` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `all` | *Удалено* | Устарело, поскольку действия больше не имеют атрибутов. |
| `asCommand` | `asCommand` | То же имя, но другое поведение. `asCommand` теперь является единственной точкой входа, когда действие выполняется как команда (Смотрите "[Один метод для ввода и вывода](#one-method-for-both-input-and-output)"). |
| `asController` | `asController` | То же имя, но другое поведение. `asController` теперь является единственной точкой входа, когда действие выполняется как контроллер (Смотрите "[Один метод для ввода и вывода](#one-method-for-both-input-and-output)"). |
| `asJob` | `asJob` | То же имя, но другое поведение. `asJob` теперь является единственной точкой входа, когда действие отправляется как задание (Смотрите "[Один метод для ввода и вывода](#one-method-for-both-input-and-output)"). |
| `asListener` | `asListener` | То же имя, но другое поведение. `asListener` теперь является единственной точкой входа, когда действие выполняется как слушатель (Смотрите "[Один метод для ввода и вывода](#one-method-for-both-input-and-output)"). |
| `attributes` | `getValidationAttributes` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `authorize` | `authorize` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `can` | *Удалено* | В версии 2 больше нет свойства `$user`. |
| `$commandSignature` | `$commandSignature` | То же самое, но должно быть `public`. В версии 2 Вы также можете использовать метод `getCommandSignature` вместо. |
| `$commandDescription` | `$commandDescription` | То же самое, но должно быть `public`. В версии 2 Вы также можете использовать метод `getCommandDescription` вместо. |
| `consoleOutput` | *Удалено* | Теперь Вы можете предоставить вывод команды непосредственно в методе `asCommand`. |
| `delegateTo` | *Удалено* | Просто используйте вместо этого `MyOtherAction::run`. То же самое касается `createFrom` и `runAs`. |
| `$errorBag` | `getValidationErrorBag` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `except` | *Удалено* | Устарело, поскольку действия больше не имеют атрибутов. |
| `failedAuthorization` | `getAuthorizationFailure` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `failedValidation` | `getValidationFailure` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `fill` | *Удалено* | Устарело, поскольку действия больше не имеют атрибутов. |
| `get` | *Удалено* | Устарело, поскольку действия больше не имеют атрибутов. |
| `getAttributesFromCommand` | *Удалено* | Теперь Вы можете анализировать ввод команды непосредственно в методе `asCommand`. |
| `getAttributesFromConstructor` | *Удалено* | Устарело, поскольку действия больше не имеют атрибутов. |
| `getAttributesFromEvent` | *Удалено* | Теперь Вы можете анализировать данные события непосредственно в методе `asListener`. |
| `getAttributesFromRequest` | *Удалено* | Теперь Вы можете анализировать данные запроса прямо в методе `asController`. |
| `getRedirectUrl` | `getValidationRedirect` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `handle` | `handle` | Тот же метод, но он больше не разрешает атрибуты из своих аргументов, так как v2 больше не имеет атрибутов. Вместо этого у Вас есть полный контроль над подписью Вашего метода. |
| `has` | *Удалено* | Устарело, поскольку действия больше не имеют атрибутов. |
| `initialized` | *Удалено* | Теперь Вы можете использовать `__construct` вместо. |
| *Added* | `make` | *(Статический)* Эквивалентно `app(MyAction::class)`. |
| `messages` | `getValidationMessages` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `middleware` | `getControllerMiddleware` или `getJobMiddleware` | В версии 2 Вам необходимо явно предоставить мидлвар для контроллеров и/или заданий. В версии 1 между ними могли быть конфликты. |
| `only` | *Удалено* | Устарело, поскольку действия больше не имеют атрибутов. |
| `prepareForValidation` | `prepareForValidation` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `registered` | *Удалено* | В версии 2 действия распознаются по запросу, а не регистрируются поставщиком услуг. |
| `response` | *Удалено* | Теперь Вы можете предоставить ответ контроллера непосредственно в методе `asController`. Обратите внимание, что `htmlResponse` и `jsonResponse` все еще существуют. |
| `routes` | `routes` | *(Статический)* Тот же метод, но Вам нужно указать свои действия у поставщика услуг, чтобы это работало (Смотрите "[Регистрация маршрутов непосредственно в действии](register-as-controller.html#registering-routes-directly-in-the-action)"). |
| `rules` | `rules` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `run` | `run` | *(Статический)* То же поведение, но теперь работает только статически. Вы можете использовать `$action->handle(...)`, если Вы ищете нестатический способ запуска Вашего действия. |
| `runningAs` | *Удалено* | Теперь Ваша логика, специфичная для шаблона, живет в методах `asX`. |
| `set` | *Удалено* | Устарело, поскольку действия больше не имеют атрибутов. |
| `user` | *Удалено* | Больше никаких помощников пользователей. Если действие требует, чтобы пользователь работал, просто передайте этого пользователя в качестве аргумента. |
| `validationData` | `getValidationData` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `validator` | `getValidator` | Такое же поведение, но применяется только при работе в качестве контроллера. |
| `withValidator` | `withValidator` | Такое же поведение, но применяется только при работе в качестве контроллера. |
